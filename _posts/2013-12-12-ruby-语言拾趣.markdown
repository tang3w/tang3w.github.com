---
layout: post
title: "Ruby 语言拾趣"
published: false
categories:
- Ruby
---

本文是我学习 Ruby 语言过程中的笔记，记录了 Ruby 语言中那些基础但又重要的概念。讨论的版本为 Ruby 2，但由于某些特性和旧版本存在不兼容的情况，会说明各版本之间的差异。

### 编码
从 Ruby 2.0 开始，默认的源文件编码是 UTF-8（[见此处][1]）。而在之前的版本中，默认编码是 ASCII。Ruby 1.9 开始支持[魔法注释][2]，如果文件中使用了非 ASCII 字符，必须通过魔法注释来指定文件的编码。Ruby 1.8 对编码不敏感，字符串只是纯粹的字节流，所以不编码也没有关系。

### 代码布局
Ruby 是[面向行的][3]（line-oriented）语言。当解析器遇到行末时，如果能判断语句是完整的，就结束语句，否则延续到下一行继续解析，比如一行的最后一个 [token][4] 是运算符或逗号。可以用分号结束语句，还可以用位于行末的反斜线延续到下一行。

单行注释以井号开始，一直延伸到物理行的末尾。多行注释以 `=begin` 打头的行开始，以 `=end` 打头的行来结束。如果 Ruby 遇到只包含 `__END__` 的一行，就会结束该程序文件。`__END__` 之后的行不会执行，但可以通过 `DATA` 对象来访问这些行。

此外，Ruby 还允许指定文件加载时执行的块（`BEGIN` blocks）和程序结束后执行的块（`END` blocks）。一个程序可以包含多个 `BEGIN` 和 `END` blocks，`BEGIN` blocks 以声明的顺序执行，`END` blocks 以相反的顺序执行。

<h3 id="GDS">通用定界语法</h3>
Ruby 提供了通用定界语法来表示各种字面量。这种语法以百分号开头，紧跟着一个字符来指定字面量的类型。例如 `%q` 和 `%Q` 表示字符串类型，`%w` 和 `%W` 表示字符串数组类型，`%i` 和 `%I` 表示符号数组类型（Ruby 2.0 可用），`%r` 表示正则表达式类型，等等。

类型字符后面紧接着定界符，定界符可以是任何非字母数字或非多字节字符。如果定界符是 `(`, `[`, `{` 和 `<` 这四个字符之一，字面量会在匹配的关闭定界符处结束，其中可包含嵌套的定界符对。对于其他定界符，字面量以下一个定界符结束。

对于多行字符串，换行符和后续每一行开头的空白都会包含在这个字符串里面。

### 基本类型
Ruby 中，整数不是 `Fixnum` 就是 `Bignum`。如果整数可以用比机器的字长少 1 的位来表示，就用 `Fixnum` 类表示；如果超出这个范围，就用 `Bignum` 类来表示。这两种类型之间的转换是透明的。

Ruby 解释器内建了有理数（[`Rational`][5]）和复数（[`Complex`][6]）的类，但没有字面量来表示它们，Ruby 没有为这些数值类型提供语言层面上的支持。

### 转义和插值
单引号字符串不支持插值，只转义反斜线和定界符；双引号字符串既支持插值，同时也比单引号字符串支持更多类型的转义。在 here document 中，如果用带引号的字符串指定终止符，引号的规则会应用到 here document，否则，使用双引号规则。

在[通用定界语法][7]中，以大写字母表示类型（`%Q`, `%W`, `%I`）的字面量中，也支持插值和转义；而对应的以小写字母表示类型（`%q`, `%w`, `%i`）的字面量却不支持插值。

### 命名约定
局部变量名以小写字母或下划线开头；实例变量名以 `@` 开头；类变量名以 `@@` 开头；全局变量名以 `$` 开头；常量名以大写字母开头。一般来说，类名和模块名采用驼峰式写法，比如 `MixedCase`；其他常量名全部大写，并以下划线分隔，例如 `NUMBER_OF_WEEK = 7`。

### 歧义消除
以小写字母开头的名字（例如 `foobar`）有两种含义：可能是局部变量，也有可能是不带参数的消息发送。这里出现了歧义，Ruby 需要分辨出到底是哪种含义。规则是：如果名字所引用的局部变量尚未初始化，就解释为不带参数的消息发送。应尽量避免局部变量和方法重名。

除此之外，以大写字母开头的名字（例如 `Foobar`）也有歧义，它可能是常量，也可能是不带参数的消息发送（Ruby 允许以大写字母开头的方法名），这时歧义消除的规则比较简单：Ruby 会认为它是个常量，如果没找到这个常量，就抛出异常。

### 弱类型
Ruby 是弱类型语言，变量的类型仅取决于它引用的对象所能响应的消息，即 [Duck typing][8]。一个变量可以在不同时候引用不同类型的对象。

### 查找常量
首先，Ruby 会依次在 `Module.nesting` 返回的模块中查找，如果没有找到，则继续在 `Module.nesting.first.ancestors` 中查找，如果 `Module.nesting.first` 是 `nil` 或模块，则在 `Object.ancestors` 中进一步查找。请参考[此文][10]。

### 类变量
在 Ruby 中，子类会共享父类中的类变量，并且父类中的类变量将覆盖子类中同名的类变量。总的来说，Ruby 查找类变量的逻辑是：逐一遍历祖先链，然后取最上游的类变量。除此之外，类变量还有许多出乎意料的地方，并且在不同版本中行为不一致。因此，很多人建议不使用它。

### 作用域
类定义、模块定义和方法定义会暂时离开先前的作用域，并打开一个新的作用域，边界由关键字 `class`, `module` 和 `def` 来确定。Ruby 查找变量时，不会越过这些作用域，也不会形成作用域链。因此，这些关键字充当了[作用域门][11]（Scope Gate）的角色。

块也会创建新的作用域，但块的作用域不是封闭的，并且可以嵌套，可以在块中访问外部变量。可以利用块来构建[扁平化作用域][12]。另外，`while`, `until` 和 `for` 循环不会创建新的作用域。循环体可以访问外部变量，在循环体中创建的变量也可以在循环体结束后访问。

### 块
块会保留它们被创建的作用域中已存在的局部变量，并且成为它们绑定的一部分。块会和该作用域共享这些变量，除非你显式将这些变量声明为块的局部变量（Ruby 1.9 支持，方法是在块参数列表的分号后指定）。在其他语言中，把这种特性称为[闭包][13]（Closure）。

### 预定义变量
Ruby 预定义了许多变量，用来处理异常、模式匹配、输入输出、环境变量，等等。许多变量以美元符号 `$` 开头，这受到了 Perl 语言的影响。此外，还有标准对象，比如 `nil`, `self`, `ARGV` 等；以及全局常量，比如 `DATA`, `FALSE`, `NIL` 等。

<h3 id="PA">并行赋值</h3>
Ruby 支持[并行赋值][14]（Parallel Assignment），即在一个赋值表达式中，可能有一个或多个[左值和右值][15]。并行赋值遵循以下规则：

1. 如果左值前缀星号，则包含尽可能多的右值；如果右值前缀星号，则试图展开。
2. 右值展开的规则是：如果它实现了 `to_a` 方法，则展开 `to_a` 返回的元素，否则不展开。
3. 如果只有一个左值，多个右值，右值将转换成数组赋给左值；如果有多个左值，但只有一个右值，右值将按照规则 2 进行展开。
4. 如果左值比右值多，其余的左值会赋为 nil；如果右值比左值多，其余的右值将被忽略。
5. 如果左值包含一个括号列表，则作为嵌套的赋值表达式来对待。

并行赋值表达式的值是右值所组成的数组。

### 布尔值
在 Ruby 中，除了预定义常量 `false` 和 `nil` 是假值之外，其余的值都作为真值来对待。Ruby 会对逻辑表达式进行[短路求值][16]，即：如果通过第一个表达式就可以确定逻辑表达式的真假，就返回它的值，不会再对第二个表达式进行求值，否则返回第二个表达式的值。

### 触发器
Ruby 的触发器（Flip-flop）鲜为人知，该特性是从 Perl 沿袭过来的。触发器复用了范围字面量的语法。当范围的任何一个边界不是整数字面量，并且作为一个条件来使用时，它就是触发器。由于触发器的行为不太直观，许多人不建议使用它。

触发器每次计算都返回一个布尔值，并保留本次计算的状态，该状态会决定下次该如何计算。触发器有两种状态，in 和 out，初始状态为 out。触发器有两种形式：`a..b` 和 `a...b`。它们的计算规则稍有差异。`a..b` 形式的计算规则如下：

1. 如果状态是 out，则计算 `a`。
2. 如果状态是 in，则计算 `b`，不管真假都返回 `true`。
3. 如果 `a` 为真，则进一步计算 `b`，否则返回 `false`。
4. 如果 `b` 为真，则将状态设置为 out，否则设置为 in。

`a...b` 的处理规则和 `a..b` 类似，不同的是：当 `a` 为真时，不会进一步计算 `b`，而是直接将状态设置为 in 并返回 `true`。

触发器就是一个简单的[有限状态机][17]，每次计算都会在两个边界之间转移，以决定下一次计算的起点。当从 `a` 转移到 `b` 后，要直到 `b` 为真时才转移到 `a`，否则一直维持 in 状态并返回 `true`。两种触发器之间的差异也只体现在：当 `a` 和 `b` 都为真时，`a..b` 会计算 `b` 并转移到 `a`；而 `a...b` 不会计算 `b`，并停留在 `b`。

### 选择控制

Ruby 提供了三种选择控制语句： `if`, `unless` 和 `case` 语句。

`if` 语句有可选的 `elsif` 和 `else` 分支。`unless` 语句的逻辑和 `if` 相反，但只支持可选的 `else` 分支。其次，`if` 和 `unless` 还可以作为语句修饰来使用。

`case` 语句和其他语言中的 `switch` 语句类似，但有些显著的差别。`case` 语句的每个 `when` 分支执行完后都会自动跳出，而不需要像 C 语言的 `switch` 那样必须显式地用 `break` 语句跳出。

`case` 语句的 `when` 分支可以测试多个表达式，用逗号隔开，表达式可以是数组的展开形式，数组会在该 `when` 分支测试之前展开，就像方法的参数列表那样处理。测试时，会依次对这个列表进行测试，直到为真时停止。

`case` 语句有两种形式：如果 `case` 后面没有表达式，那么每个 `when` 分支的表达式都当做布尔值来测试；如果 `case` 后面有表达式，则会对 `when` 分支上的表达式调用 `===` 方法，并以 `case` 后面的表达式的值为参数，来测试相等性。作为优化，官方实现在 Ruby 1.9 之后，对字符串字面量之间和数字之间不使用 `===` 比较。

选择控制语句（`if`, `unless` 和 `case`）中的测试条件和 body 可以用关键字 `then` 分隔。如果 body 从新行开始，则可省略。

选择控制语句和表达式一样也有值，它们的值等于最后执行的语句的值，如果一条语句都没有执行，其值就为 `nil`。

最后，和大多数语言一样，Ruby 也提供了[三元运算符][18]。例如 `a ? b : c`。

### 循环控制

Ruby 提供了三种循环语句：`while`, `until` 和 `for` 语句。

测试条件和 body 可以用关键字 `do`分隔，和选择控制语句一样，如果 body 另起一行开始，则可以省略。值得注意的是，虽然这里的 `do` 和 `end` 看起来像一个 block，但它不是，它不会引入新的作用域。循环体中定义的局部变量可以在外面访问。

另外，与 `if` 和 `unless` 一样，`while` 和 `until` 也可以作为语句修饰来使用。当 `while` 修饰的是 `begin/end` 块时，块至少会执行一次，就像 C 语言的 `do/while` 语句那样。

Ruby 还提供了几个关键字来进一步控制循环：`break`, `next` 和 `redo`。`break` 会立即跳出当前循环；`next` 会跳到循环的末尾，并开始下一次迭代；`redo` 和 `next` 相反，它会跳到循环的开始，重新迭代一遍，但它不会重新计算测试条件。

`break` 后面可以附带一个或多个参数。如果 `while`, `until` 和 `for` 循环调用了有参数的 `break` 语句，它们的值等于 `break` 附带的参数；否则，则它们的值为 `nil`。

### 方法定义

方法名既可以是名字，也可以是可重定义的运算符。还可以给名字加上可选的后缀以说明方法的用途。后缀 `?` 说明该方法会返回一个布尔值；后缀 `!` 说明该方法修改一个对象；后缀 `=` 说明该方法可以作为[左值][15]来使用。

`def` 除了可以定义实例方法外，还可以通过 `def expr.methodname` 的形式定义单例方法。如果实例方法定义在最外层（即任何 class 或 module 定义块之外），此时，该实例方法将作为 `Object` 类的私有实例方法，因此可以在任何地方隐式地调用它。

另外，方法块就像 `begin/end` 块，也可以包含异常控制语句，比如 `rescue`, `else` 和 `ensure`。

### 方法查找

调用方法时，如果没有指定接收者（receiver），`self` 将作为默认的接收者。接收者将依次在它的类和其祖先类中查找，一旦找到方法定义，停止搜索并调用该方法。如果没有找到方法定义，Ruby 调用接收者的 `method_missing` 方法。

### 方法调用

接收者和方法名之间可以用 `.` 或 `::` 分隔，他们的不同之处体现在：当方法名首字母大写时，如果使用 `receiver::Foo` 这种方式来调用方法，Ruby 会认为你是在访问一个常量。为了避免这种二义性，应该使用 `.` 来调用方法。

在方法中，你可以使用 `super` 关键字来调用祖先类的方法，从该方法所在类的父类开始查找。如果不带参数，会传递当前方法的参数，否则就使用 `super` 的参数。

方法的返回值是最后执行的语句的值。但是有个例外，当方法是一个 setter 方法（方法名以 `=` 结尾的方法）时，setter 方法的返回值始终是[右值][15]，实际的返回值被忽略了，这符合赋值表达式的处理规则。如果你确实希望得到一个 setter 方法的返回值，可以使用 `send` 方法来调用它们。

### 参数

Ruby 能让你灵活地控制参数，形式参数（方法定义的参数）有以下几种类型：

1. 零个或多个常规参数，和局部变量的命名一样。你还可以为它赋值来设置默认值。
2. 零个或多个关键字参数（Ruby 2.0 支持），其形式为：`name:default_value`。
3. 可选的 splat 参数，它收集多余的参数，放到一个数组中。
4. 可选的 double splat 参数，它收集未在参数列表中定义的关键字参数，放到一个哈希对象中。
5. 可选的 block 参数，只能放在参数列表最后。

参数（常规参数和关键字参数）的默认值表达式将在方法被调用时计算，并且可以引用在它之前的参数。关键字参数必须跟在常规参数的后面。

调用方法时，常规参数和 splat 参数的赋值规则和[并行赋值][19]的规则类似。

调用方法时，关键字参数会打包成一个哈希对象。如果方法没有定义关键字参数，则作为普通参数传递过去。否则会用哈希对象中的键去匹配关键字，如果匹配，则用对应的值替换默认值，否则抛出运行时错误，除非方法定义了一个 double splat 参数。即关键字参数被拆分到方法的各个关键字参数和 double splat 参数中去了。

调用方法时，还可以给参数加上 `**` 前缀，此时参数当做哈希对象，并且会展开这个哈希对象的键值，作为关键字参数传递过去。实际上，`**` 在参数列表之外也可以用，比如在哈希对象内部展开其他哈希对象：`{**{a:1}}`。

传递块有两种方法：使用字面量，或者使用 `Proc` 或 `Method` 对象。字面量用花括号 `{}` 或 `do/end` 界定，它们的区别是 `{}` 比 `do/end` 的优先级高。一般约定，使用 `{}` 界定单行 block，使用 `do/end` 界定多行 block。如果使用 `Proc` 或 `Method` 对象，还可以加上 `&` 前缀，它的含义是：这是一个 `Proc` 或 `Method` 对象，我想把它当作 block 来使用。

`block_given?` 方法可以查看方法调用时是否关联了一个 block，并返回一个布尔值。

### 取消方法定义

Ruby 支持通过关键字 `undef` 取消方法定义，当取消某个方法之后，该方法任然存在，只是标记成未定义的了。在子类中取消某个方法定义不会影响到父类。

[1]: https://bugs.ruby-lang.org/issues/6679
[2]: http://en.wikibooks.org/wiki/Ruby_Programming/Encoding#Using_Encodings
[3]: http://en.wikipedia.org/wiki/Line-oriented_programming_language
[4]: http://en.wikipedia.org/wiki/Token_(parser)#Token
[5]: http://www.ruby-doc.org/core-2.0.0/Rational.html
[6]: http://www.ruby-doc.org/core-2.0.0/Complex.html
[7]: #GDS
[8]: http://en.wikipedia.org/wiki/Duck_typing
[9]: http://cirw.in/blog/constant-lookup
[10]: http://cirw.in/blog/constant-lookup
[11]: http://hopsoft.github.io/blog/ruby-metaprogramming-idioms/#scope_gate
[12]: http://hopsoft.github.io/blog/ruby-metaprogramming-idioms/#flat_scope
[13]: http://en.wikipedia.org/wiki/Closure_(computer_programming)
[14]: http://en.wikipedia.org/wiki/Assignment_(computer_science)#Parallel_assignment
[15]: http://en.wikipedia.org/wiki/Value_(computer_science)#Assignment:_l-values_and_r-values
[16]: http://en.wikipedia.org/wiki/Short-circuit_evaluation
[17]: http://en.wikipedia.org/wiki/Finite-state_machine
[18]: http://en.wikipedia.org/wiki/%3F:
[19]: #PA
