---
layout: post
title: "并发编程：APIs 和挑战"
published: false
categories:
- translate
- Objective-C
- objc.io
---

<p id="state">注：这篇翻译已经过 objc.io 授权，原文链接是：<a href="http://www.objc.io/issue-2/concurrency-apis-and-pitfalls.html" title="Concurrent Programming: APIs and Challenges">Concurrent Programming: APIs and Challenges</a></p>

[并发][1]描述了同时运行多个任务的概念。这既可以通过单个 CPU 核心以[时分][2]的方式发生；也可以真正以并行的方式发生，只要有多个 CPU 核心可用。OS X 和 iOS 提供了若干不同的 APIs 来使用并发编程。每一种 APIs 都有不同的能力和限制，让他们可以适用于不同的任务。他们也位于不同的抽象级别。你可以用运用非常原生的方式来做，但与此同时，你也有重大的责任来让事情保持正确。

并发编程是一个非常困难的主题，包含很多复杂的问题和缺陷，当你使用如 Grand Central Dispatch 或 `NSOperationQueue` 这些 APIs 时很容易忘记。这篇文章首先对 OS X 和 iOS 上不同的并发 APIs 做了概览，然后深入挖掘并发编程固有的挑战，这与你具体使用的 API 是相独立的。

### OS X 和 iOS 上的并发 APIs

Apple 的移动和桌面操作系统为并发编程提供了相同的 APIs。在本文中，我们会看看 `pthread`，`NSThread`，Grand Central Dispatch，`NSOperationQueue` 以及 `NSRunLoop`。从技术上来说，run loops 是这些当中最奇怪的一个，因为它们不会真正使用并行。但是它和我们这个主题很接近，所以值得我们仔细看看。

我们将会从低级的 APIs 开始，逐渐带你到更高级的。我们选择这条路线是因为高级的 APIs 建立在低级的 APIs 上面。然而，当你选择实际使用的 API 时，你应该以相反的顺序：选择最高级别的抽象来完成工作，让你的并发模型保持简单。

如果你对我们为什么坚持推荐更高级别的抽象和简单的并发代码，你应该阅读本文的第二部分，[并发编程的挑战][3]，还有 [Peter Steinberger 的关于线程安全的文章][4]。

### 线程

[线程][5]是进程的子单元，进程可以被操作系统的调度器单独地调度。实际上，所有并发 APIs 底层都建立在线程上面，Grand Central Dispatch 和 operation queues 都是这样。

多个线程可以在单个 CPU 核心上同时执行（或者至少感觉它们是同时执行的）。操作系统会给每个线程赋予小的运行时间片。如果有多个 CPU 核心可以利用，那么多个线程就可以真正以并行的方式执行，因此可以减少完成某个工作的总时间。

你可以使用 Instruments 中的 [CPU strategy view][6] 来了解你的代码或框架代码在多核上调度执行的情况。

你需要牢记的是：你无法控制代码在何时何地调度，也不知道会暂停多久来让其他任务运行。这种线程调度是非常强大的技术。然而，它也带来了巨大的复杂性，随后我们将会看到。

我们先抛开这些复杂性，你可以使用 [POSIX thread][7]，或 Objective-C 包装的 API，`NSThread`，来创建自己的线程。下面这个小例子使用 `pthread` 在 100 万个数字中寻找最大值和最小值。它发起 4 个线程并行运行。很明显，通过这个例子，你应该知道为什么不应该直接使用 `pthread`。

{% highlight objective-c %}

struct threadInfo {
    uint32_t * inputValues;
    size_t count;
};

struct threadResult {
    uint32_t min;
    uint32_t max;
};

void * findMinAndMax(void *arg)
{
    struct threadInfo const * const info = (struct threadInfo *) arg;
    uint32_t min = UINT32_MAX;
    uint32_t max = 0;
    for (size_t i = 0; i < info->count; ++i) {
        uint32_t v = info->inputValues[i];
        min = MIN(min, v);
        max = MAX(max, v);
    }
    free(arg);
    struct threadResult * const result = (struct threadResult *) malloc(sizeof(*result));
    result->min = min;
    result->max = max;
    return result;
}

int main(int argc, const char * argv[])
{
    size_t const count = 1000000;
    uint32_t inputValues[count];
    
    // Fill input values with random numbers:
    for (size_t i = 0; i < count; ++i) {
        inputValues[i] = arc4random();
    }
    
    // Spawn 4 threads to find the minimum and maximum:
    size_t const threadCount = 4;
    pthread_t tid[threadCount];
    for (size_t i = 0; i < threadCount; ++i) {
        struct threadInfo * const info = (struct threadInfo *) malloc(sizeof(*info));
        size_t offset = (count / threadCount) * i;
        info->inputValues = inputValues + offset;
        info->count = MIN(count - offset, count / threadCount);
        int err = pthread_create(tid + i, NULL, &findMinAndMax, info);
        NSCAssert(err == 0, @"pthread_create() failed: %d", err);
    }
    // Wait for the threads to exit:
    struct threadResult * results[threadCount];
    for (size_t i = 0; i < threadCount; ++i) {
        int err = pthread_join(tid[i], (void **) &(results[i]));
        NSCAssert(err == 0, @"pthread_join() failed: %d", err);
    }
    // Find the min and max:
    uint32_t min = UINT32_MAX;
    uint32_t max = 0;
    for (size_t i = 0; i < threadCount; ++i) {
        min = MIN(min, results[i]->min);
        max = MAX(max, results[i]->max);
        free(results[i]);
        results[i] = NULL;
    }
    
    NSLog(@"min = %u", min);
    NSLog(@"max = %u", max);
    return 0;
}

{% endhighlight %}

`NSThread` 是 Objective-C 对 pthreads 的简单包装。这让代码在 Cocoa 环境下看起来更熟悉。例如，你可以定义一个线程作为 `NSThread` 的子类，用来封装那些你希望运行在后台的代码。在前面的例子中，你可以定义一个 `NSThread` 子类，就像这样：

{% highlight objective-c %}

@interface FindMinMaxThread : NSThread
@property (nonatomic) NSUInteger min;
@property (nonatomic) NSUInteger max;
- (instancetype)initWithNumbers:(NSArray *)numbers;
@end

@implementation FindMinMaxThread {
    NSArray *_numbers;
}

- (instancetype)initWithNumbers:(NSArray *)numbers
{
    self = [super init];
    if (self) {
        _numbers = numbers;
    }
    return self;
}

- (void)main
{
    NSUInteger min;
    NSUInteger max;
    // process the data
    self.min = min;
    self.max = max;
}
@end

{% endhighlight %}

为了启动线程，你需要创建一个新的线程对象并调用它们的 `start` 方法：

{% highlight objective-c %}

NSSet *threads = [NSMutableSet set];
NSUInteger numberCount = self.numbers.count;
NSUInteger threadCount = 4;
for (NSUInteger i = 0; i < threadCount; i++) {
    NSUInteger offset = (count / threadCount) * i;
    NSUInteger count = MIN(numberCount - offset, numberCount / threadCount);
    NSRange range = NSMakeRange(offset, count);
    NSArray *subset = [self.numbers subarrayWithRange:range];
    FindMinMaxThread *thread = [[FindMinMaxThread alloc] initWithNumbers:subset];
    [threads addObject:thread];
    [thread start];
}

{% endhighlight %}

现在，我们可以观察线程的 `isFinished` 属性来检测所有新发起的线程什么时候运行完毕，以计算结果。我们把这个练习留给感兴趣的读者。主要问题在于，直接操作线程，不管是使用 `pthread` 还是 `NSThread` APIs，都是相对来说比较笨重的体验，而且不是很符合编程的心智模式。

直接使用线程会引发的其中一个问题是：如果你的代码和底层框架代码都发起线程，活跃线程的数量将呈指数级增加。实际上，这在大项目中是个常见的问题。例如，如果你创建 8 个线程以利用 8 个 CPU 核心的优势，并且这些线程所调用的框架代码也做了同样的事（因为它不知道你已经创建的线程），结果很快就会导致成百上千的线程。线程不是免费的午餐，每个线程都会占用内存和系统资源。

接下来，我们会讨论两个基于队列的并发 APIs：Grand Central Dispatch 和 operation queues。他们通过集中管理一个[线程池][8]，协作使用每个线程来缓解这个问题。

### Grand Central Dispatch

Grand Central Dispatch (GCD) 在 OS X 10.6 和 iOS 4 中引入，来让开发者更加方便地利用设备中日益增长的 CPU 核心数量的优势。我们将在[关于底层并发 APIs][9] 的文章中更详细地介绍 GCD。

利用 GCD，你再也不用直接操作线程了。取而代之，你只需将代码块加到队列中，GCD 会在背后管理一个[线程池][8]。GCD 决定你的代码块具体在哪个线程上执行，并且它会根据可利用的系统资源来管理这些线程。这就缓解了过多的线程被创建的问题，因为现在线程被集中管理，而不用开发者考虑了。

GCD 带来的另一个重要的改变是：作为开发者，你关心的是队列中的工作项（work items）而不是线程。这个新的心智模式也更容易使用。

GCD 暴露了 5 个不同的队列：运行在主线程上的主队列（main queue），三个拥有不同优先级的后台队列（background queues），以及一个优先级更低、I/O 被限流（throttled）的后台队列。此外，你还可以创建自定义队列，既可以是串行队列，也可以是并发队列。自定义队列又是个强大的抽象，所有你调度到其中的 blocks 最终都会反映到系统的全局队列和它的线程池中。

![GCD queues][10]

使用几个优先级不同的队列看起来很直观，但我们强烈推荐你大多数情况下使用默认优先级的队列。把访问共享资源的任务调度到不同优先级的队列中会很快导致异常行为。这会造成整个程序突然停止，因为一些低优先级的任务会阻塞高优先级的任务。你可以阅读到更多关于这种现象的信息，叫做优先级反转，就在[下面][11]。

虽然 GCD 是一个底层的 C API，但使用起来却非常简单。这容易让你疏忽：即使你将 blocks 调度到 GCD 队列，所有并发编程的警告和陷阱仍然存在。请务必阅读下面的：[并发编程的挑战][12]，来了解潜在的问题。另外，在这个专题里中，我们还有一篇精彩的 [GCD API 走查][13]，包含了许多深入的解释和有价值的观点。

### Operation Queues

Operation queues 是对 GCD 暴露的队列模型的一个 Cocoa 抽象。GCD 提供了更多底层控制，而 operation queues 在它的基础上实现了一些方便的特性，这使它成为应用开发者最好、最安全的选择。

`NSOperationQueue` 类有两个不同类型的队列：主队列和自定义队列。主队列运行在主线程上，自定义队列在后台处理。在任何一种情况下，被这些队列处理的任务都用 `NSOperation` 的子类。

你可以通过两种方式来定义自己的 operations：既可以通过覆写 `main` 方法，也可以通过覆写 `start` 方法。前者做起来非常简单，但是牺牲了灵活性。作为回报，它为你管理了诸如 `isExecuting` 和 `isFinished` 这些状态属性，你只需简单地认为，当 `main` 函数返回时，operation 就结束了。

{% highlight objective-c %}

@implementation YourOperation
    - (void)main
    {
        // do your work here ...
    }
@end

{% endhighlight %}

如果你想要更多的控制，并且可能要在 operation 中执行一个异步任务的话，你可以覆写 `start` 方法：

{% highlight objective-c %}

@implementation YourOperation
    - (void)start
    {
        self.isExecuting = YES;
        self.isFinished = NO;
        // start your work, which calls finished once it's done ...
    }

    - (void)finished
    {
        self.isExecuting = NO;
        self.isFinished = YES;
    }
@end

{% endhighlight %}

注意，在这种情况下，你必须手动管理 operation 的状态。为了使一个 operation queue 能捕捉到这些状态的改变，你必须以 KVO 兼容的方式实现这些状态属性。如果你不通过默认的访问器方法来设置状态，请确保发送合适的 KVO 消息。

为了利用 operation queues 暴露出来的取消执行的特性，你应该为长时间运行的 operations 定期检查 `isCancelled` 属性。

{% highlight objective-c %}

- (void)main
{
    while (notDone && !self.isCancelled) {
        // do your processing
    }
}

{% endhighlight %}

一旦你定义了你的 operation 类，就可以很方便地将一个 operation 添加到一个队列中。

{% highlight objective-c %}

NSOperationQueue *queue = [[NSOperationQueue alloc] init];
YourOperation *operation = [[YourOperation alloc] init];
[queue  addOperation:operation];

{% endhighlight %}

另外，你也可以将 blocks 添加到 operation queues 中。这非常方便，比如：如果你想将一次性的任务调度到主队列上：

{% highlight objective-c %}

[[NSOperationQueue mainQueue] addOperationWithBlock:^{
    // do something...
}];

{% endhighlight %}

虽然以这种方式来调度任务到队列中很方便，但定义你自己的 `NSOperation` 子类会在调试的时候非常有用。如果你覆写 operation 的 `description` 方法，你就可以容易地判断某个队列中正在调度的所有 operations。

除了基本的调度 operations 或 blocks 之外，operation queues 还提供了一些对 GCD 来说不平凡的特性。比如，你可以用 `maxConcurrentOperationCount` 属性来方便地控制某个队列可以并发执行多少个 operations。将它设置为 1 就成了串行队列了，这对独立任务来说非常好。



<p class="date"><a href="http://twitter.com/floriankugler">Florian Kugler</a>, 2013 年 7 月</p>

------

[1]: http://en.wikipedia.org/wiki/Concurrency_%28computer_science%29
[2]: http://en.wikipedia.org/wiki/Preemption_%28computing%29
[3]: http://www.objc.io/issue-2/concurrency-apis-and-pitfalls.html#challenges
[4]: http://www.objc.io/issue-2/thread-safe-class-design.html
[5]: http://en.wikipedia.org/wiki/Thread_%28computing%29
[6]: http://developer.apple.com/library/mac/#documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/AnalysingCPUUsageinYourOSXApp/AnalysingCPUUsageinYourOSXApp.html
[7]: http://en.wikipedia.org/wiki/POSIX_Threads
[8]: http://en.wikipedia.org/wiki/Thread_pool_pattern
[9]: http://www.objc.io/issue-2/low-level-concurrency-apis.html
[10]: http://www.objc.io/images/issue-2/gcd-queues@2x.png
[11]: #priority-inversion
[12]: #challenges
[13]: http://www.objc.io/issue-2/low-level-concurrency-apis.html
