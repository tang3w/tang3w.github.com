---
layout: post
title: "并发编程：APIs 和挑战"
published: false
categories:
- translate
- Objective-C
- objc.io
---

<p id="state">注：这篇翻译已经过 objc.io 授权，原文链接是：<a href="http://www.objc.io/issue-2/concurrency-apis-and-pitfalls.html" title="Concurrent Programming: APIs and Challenges">Concurrent Programming: APIs and Challenges</a></p>

[并发][1]描述了同时运行多个任务的概念。这既可以通过单个 CPU 核心以[时分][2]的方式发生；也可以真正以并行的方式发生，只要有多个 CPU 核心可用。OS X 和 iOS 提供了若干不同的 APIs 来使用并发编程。每一种 APIs 都有不同的能力和限制，让他们可以适用于不同的任务。他们也位于不同的抽象级别。你可以用运用非常原生的方式来做，但与此同时，你也有重大的责任来让事情保持正确。

并发编程是一个非常困难的主题，包含很多复杂的问题和缺陷，当你使用如 Grand Central Dispatch 或 `NSOperationQueue` 这些 APIs 时很容易忘记。这篇文章首先对 OS X 和 iOS 上不同的并发 APIs 做了概览，然后深入挖掘并发编程固有的挑战，这与你具体使用的 API 是相独立的。

### OS X 和 iOS 上的并发 APIs

Apple 的移动和桌面操作系统为并发编程提供了相同的 APIs。在本文中，我们会看看 `pthread`，`NSThread`，Grand Central Dispatch，`NSOperationQueue` 以及 `NSRunLoop`。从技术上来说，run loops 是这些当中最奇怪的一个，因为它们不会真正使用并行。但是它和我们这个主题很接近，所以值得我们仔细看看。

我们将会从低级的 APIs 开始，逐渐带你到更高级的。我们选择这条路线是因为高级的 APIs 建立在低级的 APIs 上面。然而，当你选择实际使用的 API 时，你应该以相反的顺序：选择最高级别的抽象来完成工作，让你的并发模型保持简单。

如果你对我们为什么坚持推荐更高级别的抽象和简单的并发代码，你应该阅读本文的第二部分，[并发编程的挑战][3]，还有 [Peter Steinberger 的关于线程安全的文章][4]。

### 线程

[线程][5]是进程的子单元，进程可以被操作系统的调度器单独地调度。实际上，所有并发 APIs 底层都建立在线程上面，Grand Central Dispatch 和 operation queues 都是这样。

多个线程可以在单个 CPU 核心上同时执行（或者至少感觉它们是同时执行的）。操作系统会给每个线程赋予小的运行时间片。如果有多个 CPU 核心可以利用，那么多个线程就可以真正以并行的方式执行，因此可以减少完成某个工作的总时间。

你可以使用 Instruments 中的 [CPU strategy view][6] 来了解你的代码或框架代码在多核上调度执行的情况。

你需要牢记的是：你无法控制代码在何时何地调度，也不知道会暂停多久来让其他任务运行。这种线程调度是非常强大的技术。然而，它也带来了巨大的复杂性，随后我们将会看到。

我们先抛开这些复杂性，你可以使用 [POSIX thread][7]，或 Objective-C 包装的 API，`NSThread`，来创建自己的线程。下面这个小例子使用 `pthread` 在 100 万个数字中寻找最大值和最小值。它发起 4 个线程并行运行。很明显，通过这个例子，你应该知道为什么不应该直接使用 `pthread`。

{% highlight objective-c %}

struct threadInfo {
    uint32_t * inputValues;
    size_t count;
};

struct threadResult {
    uint32_t min;
    uint32_t max;
};

void * findMinAndMax(void *arg)
{
    struct threadInfo const * const info = (struct threadInfo *) arg;
    uint32_t min = UINT32_MAX;
    uint32_t max = 0;
    for (size_t i = 0; i < info->count; ++i) {
        uint32_t v = info->inputValues[i];
        min = MIN(min, v);
        max = MAX(max, v);
    }
    free(arg);
    struct threadResult * const result = (struct threadResult *) malloc(sizeof(*result));
    result->min = min;
    result->max = max;
    return result;
}

int main(int argc, const char * argv[])
{
    size_t const count = 1000000;
    uint32_t inputValues[count];
    
    // Fill input values with random numbers:
    for (size_t i = 0; i < count; ++i) {
        inputValues[i] = arc4random();
    }
    
    // Spawn 4 threads to find the minimum and maximum:
    size_t const threadCount = 4;
    pthread_t tid[threadCount];
    for (size_t i = 0; i < threadCount; ++i) {
        struct threadInfo * const info = (struct threadInfo *) malloc(sizeof(*info));
        size_t offset = (count / threadCount) * i;
        info->inputValues = inputValues + offset;
        info->count = MIN(count - offset, count / threadCount);
        int err = pthread_create(tid + i, NULL, &findMinAndMax, info);
        NSCAssert(err == 0, @"pthread_create() failed: %d", err);
    }
    // Wait for the threads to exit:
    struct threadResult * results[threadCount];
    for (size_t i = 0; i < threadCount; ++i) {
        int err = pthread_join(tid[i], (void **) &(results[i]));
        NSCAssert(err == 0, @"pthread_join() failed: %d", err);
    }
    // Find the min and max:
    uint32_t min = UINT32_MAX;
    uint32_t max = 0;
    for (size_t i = 0; i < threadCount; ++i) {
        min = MIN(min, results[i]->min);
        max = MAX(max, results[i]->max);
        free(results[i]);
        results[i] = NULL;
    }
    
    NSLog(@"min = %u", min);
    NSLog(@"max = %u", max);
    return 0;
}

{% endhighlight %}

`NSThread` 是 Objective-C 对 pthreads 的简单包装。这让代码在 Cocoa 环境下看起来更熟悉。例如，你可以定义一个线程作为 `NSThread` 的子类，用来封装那些你希望运行在后台的代码。在前面的例子中，你可以定义一个 `NSThread` 子类，就像这样：

{% highlight objective-c %}

@interface FindMinMaxThread : NSThread
@property (nonatomic) NSUInteger min;
@property (nonatomic) NSUInteger max;
- (instancetype)initWithNumbers:(NSArray *)numbers;
@end

@implementation FindMinMaxThread {
    NSArray *_numbers;
}

- (instancetype)initWithNumbers:(NSArray *)numbers
{
    self = [super init];
    if (self) {
        _numbers = numbers;
    }
    return self;
}

- (void)main
{
    NSUInteger min;
    NSUInteger max;
    // process the data
    self.min = min;
    self.max = max;
}
@end

{% endhighlight %}

为了启动线程，你需要创建一个新的线程对象并调用它们的 `start` 方法：

{% highlight objective-c %}

NSSet *threads = [NSMutableSet set];
NSUInteger numberCount = self.numbers.count;
NSUInteger threadCount = 4;
for (NSUInteger i = 0; i < threadCount; i++) {
    NSUInteger offset = (count / threadCount) * i;
    NSUInteger count = MIN(numberCount - offset, numberCount / threadCount);
    NSRange range = NSMakeRange(offset, count);
    NSArray *subset = [self.numbers subarrayWithRange:range];
    FindMinMaxThread *thread = [[FindMinMaxThread alloc] initWithNumbers:subset];
    [threads addObject:thread];
    [thread start];
}

{% endhighlight %}

现在，我们可以观察线程的 `isFinished` 属性来检测所有新发起的线程什么时候运行完毕，以计算结果。我们把这个练习留给感兴趣的读者。主要问题在于，直接操作线程，不管是使用 `pthread` 还是 `NSThread` APIs，都是相对来说比较笨重的体验，而且不是很符合编程的心智模式。

直接使用线程会引发的其中一个问题是：如果你的代码和底层框架代码都发起线程，活跃线程的数量将呈指数级增加。实际上，这在大项目中是个常见的问题。例如，如果你创建 8 个线程以利用 8 个 CPU 核心的优势，并且这些线程所调用的框架代码也做了同样的事（因为它不知道你已经创建的线程），结果很快就会导致成百上千的线程。线程不是免费的午餐，每个线程都会占用内存和系统资源。

接下来，我们会讨论两个基于队列的并发 APIs：Grand Central Dispatch 和 operation queues。他们通过集中管理一个[线程池][8]，协作使用每个线程来缓解这个问题。

### Grand Central Dispatch

Grand Central Dispatch (GCD) 在 OS X 10.6 和 iOS 4 中引入，来让开发者更加方便地利用设备中日益增长的 CPU 核心数量的优势。我们将在[关于底层并发 APIs][9] 的文章中更详细地介绍 GCD。

利用 GCD，你再也不用直接操作线程了。取而代之，你只需将代码块加到队列中，GCD 会在背后管理一个[线程池][8]。GCD 决定你的代码块具体在哪个线程上执行，并且它会根据可利用的系统资源来管理这些线程。这就缓解了过多的线程被创建的问题，因为现在线程被集中管理，而不用开发者考虑了。

GCD 带来的另一个重要的改变是：作为开发者，你关心的是队列中的工作项（work items）而不是线程。这个新的心智模式也更容易使用。

GCD 暴露了 5 个不同的队列：运行在主线程上的主队列（main queue），三个拥有不同优先级的后台队列（background queues），以及一个优先级更低、I/O 被限流（throttled）的后台队列。此外，你还可以创建自定义队列，既可以是串行队列，也可以是并发队列。自定义队列又是个强大的抽象，所有你调度到其中的 blocks 最终都会反映到系统的全局队列和它的线程池中。

![GCD queues][10]

使用几个优先级不同的队列看起来很直观，但我们强烈推荐你大多数情况下使用默认优先级的队列。把访问共享资源的任务调度到不同优先级的队列中会很快导致异常行为。这会造成整个程序突然停止，因为一些低优先级的任务会阻塞高优先级的任务。你可以阅读到更多关于这种现象的信息，叫做优先级反转，就在[下面][11]。

虽然 GCD 是一个底层的 C API，但使用起来却非常简单。这容易让你疏忽：即使你将 blocks 调度到 GCD 队列，所有并发编程的警告和陷阱仍然存在。请务必阅读下面的：[并发编程的挑战][12]，来了解潜在的问题。另外，在这个专题里中，我们还有一篇精彩的 [GCD API 走查][13]，包含了许多深入的解释和有价值的观点。

### Operation Queues

Operation queues 是对 GCD 暴露的队列模型的一个 Cocoa 抽象。GCD 提供了更多底层控制，而 operation queues 在它的基础上实现了一些方便的特性，这使它成为应用开发者最好、最安全的选择。

`NSOperationQueue` 类有两个不同类型的队列：主队列和自定义队列。主队列运行在主线程上，自定义队列在后台处理。在任何一种情况下，被这些队列处理的任务都用 `NSOperation` 的子类。

你可以通过两种方式来定义自己的 operations：既可以通过覆写 `main` 方法，也可以通过覆写 `start` 方法。前者做起来非常简单，但是牺牲了灵活性。作为回报，它为你管理了诸如 `isExecuting` 和 `isFinished` 这些状态属性，你只需简单地认为，当 `main` 函数返回时，operation 就结束了。

{% highlight objective-c %}

@implementation YourOperation
    - (void)main
    {
        // do your work here ...
    }
@end

{% endhighlight %}

如果你想要更多的控制，并且可能要在 operation 中执行一个异步任务的话，你可以覆写 `start` 方法：

{% highlight objective-c %}

@implementation YourOperation
    - (void)start
    {
        self.isExecuting = YES;
        self.isFinished = NO;
        // start your work, which calls finished once it's done ...
    }

    - (void)finished
    {
        self.isExecuting = NO;
        self.isFinished = YES;
    }
@end

{% endhighlight %}

注意，在这种情况下，你必须手动管理 operation 的状态。为了使一个 operation queue 能捕捉到这些状态的改变，你必须以 KVO 兼容的方式实现这些状态属性。如果你不通过默认的访问器方法来设置状态，请确保发送合适的 KVO 消息。

为了利用 operation queues 暴露出来的取消执行的特性，你应该为长时间运行的 operations 定期检查 `isCancelled` 属性。

{% highlight objective-c %}

- (void)main
{
    while (notDone && !self.isCancelled) {
        // do your processing
    }
}

{% endhighlight %}

一旦你定义了你的 operation 类，就可以很方便地将一个 operation 添加到一个队列中。

{% highlight objective-c %}

NSOperationQueue *queue = [[NSOperationQueue alloc] init];
YourOperation *operation = [[YourOperation alloc] init];
[queue  addOperation:operation];

{% endhighlight %}

另外，你也可以将 blocks 添加到 operation queues 中。这非常方便，比如：如果你想将一次性的任务调度到主队列上：

{% highlight objective-c %}

[[NSOperationQueue mainQueue] addOperationWithBlock:^{
    // do something...
}];

{% endhighlight %}

虽然以这种方式来调度任务到队列中很方便，但定义你自己的 `NSOperation` 子类会在调试的时候非常有用。如果你覆写 operation 的 `description` 方法，你就可以容易地判断某个队列中正在调度的所有 operations。

除了基本的调度 operations 或 blocks 之外，operation queues 还提供了一些对 GCD 来说不平凡的特性。比如，你可以用 `maxConcurrentOperationCount` 属性来方便地控制某个队列可以并发执行多少个 operations。将它设置为 1 就成了串行队列了，这对独立任务来说非常有用。

另一个方便的特性是：可以根据 operations 的优先级对一个队列中的所有 operations 进行排序。这与 GCD 的队列优先级不同，它只影响某个队列所调度的 operations 的执行顺序。如果你想对执行顺序进行除 5 个标准优先级之外的更多控制，你可以像这样指定 operations 之间的依赖：

{% highlight objective-c %}

[intermediateOperation addDependency:operation1];
[intermediateOperation addDependency:operation2];
[finishedOperation addDependency:intermediateOperation];

{% endhighlight %}

以上简单的代码保证了 `operation1` 和 `operation2` 将在 `intermediateOperation` 之前执行，而 `intermediateOperation` 将在 `finishedOperation` 之前执行。Operation dependencies 是一个用来指定执行顺序的强大机制。它能让你创建 operation groups，以保证在依赖它的 operation 之前执行，或者在一个并发队列中串行化 operations。

通过非常自然的抽象，operation queues 也带来了一些相对于使用 GCD API 的小的性能问题。然而，大多数情况下，这种影响是微不足道的，并且 operation queues 是合适的选择。

### Run Loops

Run loops 从技术上来说，不是像 GCD 或 operation queues 那样的并发机制，因为它们不能并行地执行任务。但是，run loops 和在 main dispatch/operation queue 上执行任务有直接联系，并且它们提供了异步执行代码的机制。

Run loops 比 operation queues 或 GCD 更易于使用，因为你不必处理并发的复杂性，仍然可以让事情变得异步。

一个 run loop 总是绑定在某个线程上。Main run loop 和 main thread 关联，在每个 Cocoa 和 CocoaTouch 应用程序中扮演着核心的角色，因为它控制着 UI 时间，计时器，以及其他内核事件。当你启动一个计时器、使用 `NSURLConnection`，或调用 `performSelector:withObject:afterDelay:`，幕后都使用 run loops 来执行这些异步任务。

当你使用一个依赖 run loop 的方法时，你需要谨记的是，run loops 可以在不同模式下运行。每种模式定义了 run loop 可以响应的事件集合。这是一个将 main run loop 中某些任务的优先级暂时调整到比其他任务高的不错的方法。

一个典型的例子是 iOS 中的滚动。当你在滚动的时候，run loop 不在默认的模式下运行，因此它不会响应一些事件，比如之前你启动的计时器。一旦滚动结束，run loop 回到默认的模式，已入队列的事件才会执行。如果你想一个计时器在滚动期间也能触发，你需要以 `NSRunLoopCommonModes` 模式将它加入 run loop。

Main run loop 总是运行于主线程上。其他线程默认没有 run loop。你也可以给其他线程也设置一个 run loop，但是很少情况下需要这样做。大多数时候使用 main run loop 更容易，如果你需要做更繁重的工作，不想让它在主线程执行，那你也可以把它从 main run loop 派发到其他队列。在 Chris 的文章[常见的后台实践][14]中，有些很好的例子来说明这种模式。

如果你真的需要为其他线程设置 run loop，别忘了至少添加一个 input source 进去。如果 run loop 没有设置 input source，每次运行它都将立即结束。

### 并发的挑战

写并发的程序会带来许多陷阱。只要你用并发来做不寻常的事情，并行任务之间相互作用的不同状态就变得扑朔迷离。问题就会以非确定性的方式发生，使调试并发代码变得更加困难。

关于并发程序的难以预料的行为，有个著名的例子：1995 年，NASA 发射探索者号到火星，成功着陆后不久，探索者号几乎突然中止。重启火星探测器后，才知道原因：它遇到了一个叫做*优先级反转*的现象，有个低优先级的线程阻塞了一个高优先级的线程。我们将在下面研究这个问题。这个例子说明，即使拥有巨大资源和众多的天才工程师，并发也会通过许多方式反咬你一口。

### 共享资源

并发问题的万恶之源是：从多个线程访问共享资源。一个资源可以是对象的属性，一块内存，一个网络设备，一个文件等等。任何多线程共享的东西都是潜在的冲突点，你必须采取安全的手段来防止这种冲突。

为了演示这个问题，我们来看一个简单的例子，这个例子中，资源就是用作计数器的一个整数属性。就是说，我们有并行运行的两个线程，A 和 B，并且它们试图同时增加计数器。问题在于你所写的一个 C 或 Objective-C 语句通常并不是一条 CPU 机器指令。为了增加计数器，要先从内存中读取当前值，然后把值加一，最后写回到内存中。

想象一下，危险会在两个线程试图同时做这件事的时候发生。比如：线程 A 和线程 B 同时从内存中读取计数器的值，也就是 17。然后线程 A 将计数器加 1，并把结果 18 写回到内存中。与此同时，线程 B 也将计数器加 1 并把 18 写入内存，刚好在线程 A 之后。此时，数据损坏了，因为计数器从 17 加了两次后，变成了 18。

![Race condition][15]

这个问题称为一个[竞争条件][16]，它经常发生在：当多个线程访问一个共享资源时，一个线程对资源操作还没有结束，另一个线程又开始访问它。如果你不仅仅是写一个整数，而是一个复杂的结构到内存，甚至可能导致正当写入的时候，第二个线程恰好读取内存，因此就会看见半新半旧或未初始化的数据。为了避免这种事情发生，多线程应该以互斥的方式访问共享资源。

实际情况会比这种更复杂，因为现代 CPUs 会改变内存读写顺序以进行优化（[乱序执行][17]）。

### 互斥

[互斥][18]访问意味着同一时间只有一个线程访问某个资源。为了保证这点，每个需要访问共享资源的线程需要先获取一个这个资源的[互斥锁][19]，一旦完成操作，它就释放这个锁，这样，其他线程才又机会访问这个资源。

![Mutex locking][20]

为了保证互斥访问，锁必须还要控制 CPU 乱序执行造成的问题。如果你不能依赖 CPU 访问内存的顺序和你程序定义的指令顺序一致，那么保证互斥访问还不够。为了应付 CPU 优化策略带来的副作用，可以使用[内存屏障][21]。设置一个内存屏障可以保证乱序执行不会跨越屏障。

当然，实现一个互斥锁本身也需要避免竞争条件，这是一个不寻常的任务，并且需要特殊的现代 CPUs 的指令，你可以阅读更多 Daniel 的关于原子性操作的文章：[底层并发技术][22]。

Objective-C 通过将属性声明为原子的形式，为锁带来了语言层面的支持。实际上，属性默认就是原子的。将属性声明成原子的结果是，每次访问这个属性都会有隐式的锁和解锁。以防万一，可以把所有属性都声明为原子的。但是，所会带来一定的开销。

获取资源的锁总会带来性能的开销。获取和释放锁也需要避免竞争条件，在多核系统中，这是不寻常的事。并且当需要获取一个锁时，线程可能不得不等待，因为其他线程已经抢占这个锁了。这时，这个线程将会休眠，并且在其他线程释放锁时得到通知。所有这些操作都很昂贵和复杂。

有各种各样的锁。有些锁在没有竞争时很快，但在有竞争时就力不从心了。有些锁在正常情况下表现稍差，但是在有竞争时效率却更好（[锁竞争][23]指的是当一个或多个线程试图获取已经被其他线程抢占的锁）。

这里需要做一个权衡：获取和释放锁都会带来开销（锁的开销）。因此，你要确保你不会经常出入[临界区域][24]（即获取和释放锁）。同时，如果你为大范围代码获取一个锁，那你就会遇到锁竞争的风险，其他线程通常无法正常工作，因为他们在等待获取一个锁。这不是一个容易解决的问题。

一个常见的问题是代码看起来应该并发运行，但实际情况却是同一时刻只有一个激活的线程，原因就是共享资源设置了锁。通常很难预料你的代码在多核上是如何调度的。你可以使用 Instrument 的 [CPU strategy view][25] 来查看你是否高效地利用了 CPU 的多核。

### 死锁

互斥锁解决了竞争条件的问题，但是不幸地，同时它们也带来了新的问题（[其中包括][26]）：死锁。死锁发生在当多个线程相互等待结束时，被卡住了。

![Dead locks][27]

考虑下面这个例子，它交换两个变量的值：

{% highlight objective-c %}

void swap(A, B)
{
    lock(lockA);
    lock(lockB);
    int a = A;
    int b = B;
    A = b;
    B = a;
    unlock(lockB);
    unlock(lockA);
}

{% endhighlight %}

这在大多数时候都工作正常。但是当两个线程同时用相反的变量去调用它时：

{% highlight objective-c %}

swap(X, Y); // thread 1
swap(Y, X); // thread 2

{% endhighlight %}

就会导致死锁。线程 1 获取了一个 X 的锁，线程 2 获取了一个 Y 的锁。现在，它们都等待另一个锁，但是永远都获取不到。

<p class="date"><a href="http://twitter.com/floriankugler">Florian Kugler</a>, 2013 年 7 月</p>

------

[1]: http://en.wikipedia.org/wiki/Concurrency_%28computer_science%29
[2]: http://en.wikipedia.org/wiki/Preemption_%28computing%29
[3]: http://www.objc.io/issue-2/concurrency-apis-and-pitfalls.html#challenges
[4]: http://www.objc.io/issue-2/thread-safe-class-design.html
[5]: http://en.wikipedia.org/wiki/Thread_%28computing%29
[6]: http://developer.apple.com/library/mac/#documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/AnalysingCPUUsageinYourOSXApp/AnalysingCPUUsageinYourOSXApp.html
[7]: http://en.wikipedia.org/wiki/POSIX_Threads
[8]: http://en.wikipedia.org/wiki/Thread_pool_pattern
[9]: http://www.objc.io/issue-2/low-level-concurrency-apis.html
[10]: http://www.objc.io/images/issue-2/gcd-queues@2x.png
[11]: #priority-inversion
[12]: #challenges
[13]: http://www.objc.io/issue-2/low-level-concurrency-apis.html
[14]: http://www.objc.io/issue-2/common-background-practices.html
[15]: http://www.objc.io/images/issue-2/race-condition@2x.png
[16]: http://en.wikipedia.org/wiki/Race_conditions#Software
[17]: http://en.wikipedia.org/wiki/Out-of-order_execution
[18]: http://en.wikipedia.org/wiki/Mutex
[19]: http://en.wikipedia.org/wiki/Lock_%28computer_science%29
[20]: http://www.objc.io/images/issue-2/locking@2x.png
[21]: http://en.wikipedia.org/wiki/Memory_barrier
[22]: http://www.objc.io/issue-2/low-level-concurrency-apis.html
[23]: http://en.wikipedia.org/wiki/Lock_%28computer_science%29#Granularity
[24]: http://en.wikipedia.org/wiki/Critical_section
[25]: http://developer.apple.com/library/mac/#documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/AnalysingCPUUsageinYourOSXApp/AnalysingCPUUsageinYourOSXApp.html
[26]: http://en.wikipedia.org/wiki/Lock_%28computer_science%29#The_problems_with_locks
[27]: http://www.objc.io/images/issue-2/dead-lock@2x.png
